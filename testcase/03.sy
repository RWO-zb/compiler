CONST INT GLOBAL_MAX_DEPTH = 3;
CONST FLOAT PRECISION_TARGET = 0.001;

INT global_operation_count = 0;
FLOAT global_accumulator = 0.0;

INT check_condition_complex(INT val_a, FLOAT val_b, INT limit) {
    INT result_flag = 0;
    FLOAT temp_float;

    temp_float = val_b * limit + val_a;

    IF (val_a > limit && val_b < limit / 2.0 + PRECISION_TARGET || val_a + limit * 2 == 0 ) {
        result_flag = 1;
    } ELSE {
        IF (temp_float >= 0.0 != !(val_a + 1) ) {
            result_flag = 2;
        }
    }
    global_operation_count = global_operation_count + 1;
    RETURN result_flag;
}

int manipulate_values(INT x, FLOAT y, INT depth_level) {
    FLOAT local_val_f;
    INT local_val_i;
    INT condition_res;

    global_operation_count = global_operation_count + 1;

    IF (depth_level > GLOBAL_MAX_DEPTH) {
        RETURN x + y;
    }

    local_val_i = x * depth_level - (global_operation_count % 5);
    local_val_f = y / (depth_level + 1.0) + global_accumulator;

    condition_res = check_condition_complex(local_val_i, local_val_f, x + depth_level);

    IF (condition_res == 1) {
        global_accumulator = global_accumulator + local_val_f * 0.5;
        RETURN manipulate_values(local_val_i / 2, local_val_f + condition_res, depth_level + 1) - global_accumulator;
    } ELSE {
        IF (condition_res == 2) {
            global_accumulator = global_accumulator - local_val_i;
            RETURN manipulate_values(x + 5, y * 1.1, depth_level + 1) * PRECISION_TARGET;
        } ELSE {
            global_accumulator = (global_accumulator + x + y) / 3.0;
        }
    }
    RETURN (local_val_f - local_val_i) * depth_level;
}

VOID update_globals_conditionally(INT check_val, FLOAT threshold) {
    INT mod_val;
    mod_val = check_val % (GLOBAL_MAX_DEPTH + 2);

    IF ( global_accumulator > threshold && mod_val != 1 || global_operation_count < 5 && threshold < 0.0 ) {
        global_int_holder = check_val + global_operation_count;
        global_float_holder = global_accumulator * mod_val - threshold;
    } ELSE {
        global_int_holder = -mod_val;
        global_float_holder = threshold / (mod_val + 0.5);
    }
    RETURN;
}

INT global_int_holder = 0;
FLOAT global_float_holder = 0.0;

INT MAIN() {
    INT main_var_x = 10;
    FLOAT main_var_y = 2.5;
    INT loop_sim_count = 0;
    FLOAT final_result_f;
    INT final_result_i;
    CONST INT START_DEPTH = 1;

    global_int_holder = main_var_x;
    global_float_holder = main_var_y * 2.0;

    process_loop_iteration(loop_sim_count, main_var_x, main_var_y);
    loop_sim_count = loop_sim_count + 1;
    process_loop_iteration(loop_sim_count, global_int_holder, global_float_holder - 1.0);
    loop_sim_count = loop_sim_count + 1;
    process_loop_iteration(loop_sim_count, main_var_x / 2, global_accumulator);


    final_result_f = manipulate_values(main_var_x + loop_sim_count, main_var_y - loop_sim_count * 0.1, START_DEPTH);
    update_globals_conditionally(global_operation_count, final_result_f);

    IF (global_int_holder > global_operation_count || global_float_holder < PRECISION_TARGET) {
        final_result_i = global_int_holder * 2 - check_condition_complex(global_int_holder, global_float_holder, GLOBAL_MAX_DEPTH);
    } ELSE {
        final_result_i = (global_operation_count + global_int_holder) / (START_DEPTH + 1);
    }

    RETURN final_result_i % 100;
}

VOID process_loop_iteration(INT iter_count, INT current_x, FLOAT current_y) {
    FLOAT temp_f;
    INT temp_i;
    CONST INT MAGIC_NUMBER = 7;

    temp_f = manipulate_values(current_x - iter_count, current_y + iter_count, iter_count);
    temp_i = check_condition_complex(current_x, temp_f, MAGIC_NUMBER - iter_count);

    IF (temp_i == 0 && temp_f > iter_count + 1.0 ) {
        update_globals_conditionally(current_x + temp_i, temp_f / 2.0);
    } ELSE {
        IF (temp_i != 0) {
           global_accumulator = global_accumulator + temp_i;
        }
    }
    global_operation_count = global_operation_count + MAGIC_NUMBER;
    RETURN;
}