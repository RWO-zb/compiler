INT global_int_var;
FLOAT global_float_var = 10.5;
CONST INT MAX_VALUE = 100;
CONST FLOAT PI = 3.14;

INT add_numbers(INT num_a, INT num_b) {
    INT sum_result;
    sum_result = num_a + num_b;
    RETURN sum_result;
}


VOID process_data(INT input_val) {
    INT local_copy = input_val;
    INT threshold = 50;
    INT is_large;
    INT is_active = 1;
    INT inverted_active;

    local_copy = local_copy + 5 * 2;

    IF (local_copy > threshold) {
        is_large = 1;
    } ELSE {
        is_large = 0;
    }

    inverted_active = !is_active;

    IF (is_large == 1 && inverted_active == 0 || local_copy == MAX_VALUE) {
        global_int_var = local_copy;
    }

    IF ( local_copy <= threshold + 10 ) {
        global_float_var = global_float_var - 1.0;
    }

    IF ( input_val != 0 ) {
        FLOAT new_val;
        new_val = input_val * PI;
    }

    RETURN;
}

INT MAIN() {
    INT loop_counter;
    INT _val_a = 10;
    INT val_b = 20;
    INT result_sum;
    FLOAT complex_res;
    INT compare_flag_gt;
    INT compare_flag_le;
    INT compare_flag_eq;
    INT unary_negative_val;

    global_int_var = 5;
    loop_counter = 0;

    result_sum = add_numbers(_val_a, val_b);
    process_data(result_sum);

    _val_a = global_int_var;
    complex_res = calculate_complex(_val_a, global_float_var, loop_counter);

    unary_negative_val = -val_b;

    
    if(result_sum <= MAX_VALUE){
        compare_flag_le = 1;
    }
    else{
        compare_flag_le = 0;
    }
    if(global_int_var == 5){
        compare_flag_eq = 1;
    }
    else{
        compare_flag_eq = 0;
    }

    IF (compare_flag_gt == 1 || complex_res < 0.0) {
        loop_counter = loop_counter + 1;
    } 
    ELSE {
        val_b = val_b + unary_negative_val;
    }

    process_data(val_b / 2 + (MAX_VALUE % 7));

    RETURN 0;
}

int another_function_example(INT param1, INT param2) {
    CONST INT LOCAL_CONST = 10;
    INT intermediate;
    INT int_intermediate;

    intermediate = param1 * LOCAL_CONST;
    int_intermediate = param2 + LOCAL_CONST - 5;

    IF (intermediate >= 0 && int_intermediate != 0) {
        RETURN intermediate / int_intermediate;
    }

    RETURN -1;
}